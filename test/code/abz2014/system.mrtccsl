assume {
    duration : -1min <= fly_jitter <= 1min;
    continuous process fly_jitter with normal (0s,0.5min);
    duration : -1min <= land_jitter <= 1min;
    continuous process land_jitter with normal (0s,0.5min);

    handle {
        committed {
            duration : 1s <= d <= 2hour;
            continuous process d with exponential (30min);

            discrete process rate with 0 1 ~ 1:1;
        };
    };
    vars {
        valve {
            door {
                duration : 0.96s <= front_extension <= 1.44s;
                continuous process front_extension with normal (1.2s, 0.12s);
                duration : 1.2s <= left_extension <= 1.8s;
                continuous process left_extension with normal (1.5s, 0.15s);
                duration : 1.2s <= right_extension <= 1.8s;
                continuous process right_extension with normal (1.5s, 0.15s);
                duration : 0.96s <= front_retraction <= 1.44s;
                continuous process front_retraction with normal (1.2s, 0.12s);
                duration : 1.28s <= left_retraction <= 1.92s;
                continuous process left_retraction with normal (1.6s, 0.16s);
                duration : 1.28s <= right_retraction <= 1.92s;
                continuous process right_retraction with normal (1.6s, 0.16s);
            };
            gear {
                duration : 0.96s <= front_extension <= 1.44s;
                continuous process front_extension with normal (1.2s, 0.12s);
                duration : 1.28s <= left_extension <= 1.92s;
                continuous process left_extension with normal (1.6s, 0.16s);
                duration : 1.28s <= right_extension <= 1.92s;
                continuous process right_extension with normal (1.6s, 0.16s);
                duration : 0.96s <= front_retraction <= 1.44s;
                continuous process front_retraction with normal (1.2s, 0.12s);
                duration : 1.28s <= left_retraction <= 1.92s;
                continuous process left_retraction with normal (1.6s, 0.16s);
                duration : 1.28s <= right_retraction <= 1.92s;
                continuous process right_retraction with normal (1.6s, 0.16s);
            };
        };
        lock {
            door {
                duration : 0.32s <= front_unlock <= 0.48s;
                continuous process front_unlock with normal (0.4s, 0.04s);
                duration : 0.32s <= left_unlock <= 0.48s;
                continuous process left_unlock with normal (0.4s, 0.04s);
                duration : 0.32s <= right_unlock <= 0.48s;
                continuous process right_unlock with normal (0.4s, 0.04s);

                duration : 0.24s <= front_lock <= 0.36s;
                continuous process front_lock with normal (0.3s, 0.03s);
                duration : 0.24s <= left_lock <= 0.36s;
                continuous process left_lock with normal (0.3s, 0.03s);
                duration : 0.24s <= right_lock <= 0.36s;
                continuous process right_lock with normal (0.3s, 0.03s);
            };
            gear {
                up {
                    duration : 0.64s <= front_unlock <= 0.96s;
                    continuous process front_unlock with normal (0.8s, 0.08s);
                    duration : 0.64s <= left_unlock <= 0.96s;
                    continuous process left_unlock with normal (0.8s, 0.08s);
                    duration : 0.64s <= right_unlock <= 0.96s;
                    continuous process right_unlock with normal (0.8s, 0.08s);

                    duration : 0.32s <= front_lock <= 0.48s;
                    continuous process front_lock with normal (0.4s, 0.04s);
                    duration : 0.32s <= left_lock <= 0.48s;
                    continuous process left_lock with normal (0.4s, 0.04s);
                    duration : 0.32s <= right_lock <= 0.48s;
                    continuous process right_lock with normal (0.4s, 0.04s);
                };
                down {
                    duration : 0.64s <= front_unlock <= 0.96s;
                    continuous process front_unlock with normal (0.8s, 0.08s);
                    duration : 0.64s <= left_unlock <= 0.96s;
                    continuous process left_unlock with normal (0.8s, 0.08s);
                    duration : 0.64s <= right_unlock <= 0.96s;
                    continuous process right_unlock with normal (0.8s, 0.08s);

                    duration : 0.32s <= front_lock <= 0.48s;
                    continuous process front_lock with normal (0.4s, 0.04s);
                    duration : 0.32s <= left_lock <= 0.48s;
                    continuous process left_lock with normal (0.4s, 0.04s);
                    duration : 0.32s <= right_lock <= 0.48s;
                    continuous process right_lock with normal (0.4s, 0.04s);
                }
            }
        };
    };
} structure {
    try_flying = periodic 30min with drift fly_jitter offset 10min;
    try_landing = periodic 30min with drift land_jitter offset 30 min;  
    flying alternates onground;
    // TODO: should add try flying and try landing and only allow it if the gear is in the right place
    valve {
        door {
            retraction {
                var open, close: clock;
                // open alternates close;
            };
            extension {
                var open, close : clock;
                // open alternates close;
            };
        };
        gear {
            retraction {
                var open, close: clock;
                // open alternates close;
            };
            extension {
                var open, close: clock;
                // open alternates close;
            };
        };
        general {
            open alternates close;
        };
        allow door.retraction.close door.retraction.open door.extension.close door.extension.open gear.retraction.close gear.retraction.open gear.extension.close gear.extension.open from general.open until general.close; // it is a deviation from how the system may behave because that would require modelling of the physical behaviour
    };
    cylinder {
        door {
            front {
                extended alternates retracted;
            };
            left {
                extended alternates retracted;
            };
            right {
                extended alternates retracted;
            };
        };
        gear {
            front {
                retracted alternates extended;
            };
            left {
                retracted alternates extended;
            };
            right {
                retracted alternates extended;
            };
        };
    };
    lock { // TODO: maybe just maybe we don't actually lock, only unlock?
        door {
            front {
                unlock alternates lock;
            };
            left {
                unlock alternates lock;
            };
            right {
                unlock alternates lock;
            };
        };
        gear {
            up {
                front {
                    lock alternates unlock;
                };
                left {
                    lock alternates unlock;
                };
                right {
                    lock alternates unlock;
                };
            };
            down {
                front {
                    unlock alternates lock;
                };
                left {
                    unlock alternates lock;
                };
                right {
                    unlock alternates lock;
                };
            };
        };
    };

    // relations between valves and cylinders
    // high to down
    cylinder.door.front.extended = delay valve.door.extension.open by vars.valve.door.front_extension;
    cylinder.door.left.extended = delay valve.door.extension.open by vars.valve.door.left_extension;
    cylinder.door.right.extended = delay valve.door.extension.open by vars.valve.door.right_extension;
    // down to high
    cylinder.door.front.retracted = delay valve.door.retraction.open by vars.valve.door.front_retraction;
    cylinder.door.left.retracted = delay valve.door.retraction.open by vars.valve.door.left_retraction;
    cylinder.door.right.retracted = delay valve.door.retraction.open by vars.valve.door.right_retraction;

    // relations between valves and 
    // high to down
    cylinder.gear.front.extended = delay valve.gear.extension.open by vars.valve.gear.front_extension;
    cylinder.gear.left.extended = delay valve.gear.extension.open by vars.valve.gear.left_extension;
    cylinder.gear.right.extended = delay valve.gear.extension.open by vars.valve.gear.right_extension;
    // down to high
    cylinder.gear.front.retracted = delay valve.gear.retraction.open by vars.valve.gear.front_retraction;
    cylinder.gear.left.retracted = delay valve.gear.retraction.open by vars.valve.gear.left_retraction;
    cylinder.gear.right.retracted = delay valve.gear.retraction.open by vars.valve.gear.right_retraction;

    // TODO: valves cannot close before the cylinder finishes extension

    sensor {
        pressure {
            var present, lacking : clock;
        };
        door {
            front {
                var open, closed : clock;
                var locked, unlocked : clock;
            };
            left {
                var open, closed : clock;
                var locked, unlocked : clock;
            };
            right {
                var open, closed : clock;
                var locked, unlocked : clock;
            };
            var open, closed : clock;
            open = slowest of front.open left.open right.open;
            closed = slowest of front.closed left.closed right.closed;
            locked = slowest of front.locked left.locked right.locked;
            unlocked = slowest of front.unlocked left.unlocked right.unlocked;
        };
        gear {
            front {
                var retracted, extended : clock;
            };
            left {
                var retracted, extended : clock;
            };
            right {
                var retracted, extended : clock;
            };
            var retracted, extended : clock;
            retracted = slowest of front.retracted left.retracted right.retracted;
            extended = slowest of front.extended left.extended right.extended;
            up {
                front {
                    var locked, unlocked : clock;
                };
                left {
                    var locked, unlocked : clock;
                };
                right {
                    var locked, unlocked : clock;
                };
                var locked, unlocked : clock;
                locked = slowest of front.locked left.locked right.locked;
                unlocked = slowest of front.unlocked left.unlocked right.unlocked;
            };
            down {
                front {
                    var locked, unlocked : clock;
                };
                left {
                    var locked, unlocked : clock;
                };
                right {
                    var locked, unlocked : clock;
                };
                var locked, unlocked : clock;
                locked = slowest of front.locked left.locked right.locked;
                unlocked = slowest of front.unlocked left.unlocked right.unlocked;
            };
            shockabsorbers {
                var relaxed, compressed : clock;
            };
        }
    };

    // relations between locks and sensors
    // doors
    sensor.door.front.unlocked = delay lock.door.front.unlock by vars.lock.door.front_unlock;
    sensor.door.left.unlocked = delay lock.door.left.unlock by vars.lock.door.left_unlock;
    sensor.door.right.unlocked = delay lock.door.right.unlock by vars.lock.door.right_unlock;

    sensor.door.front.locked = delay lock.door.front.lock by vars.lock.door.front_lock;
    sensor.door.left.locked = delay lock.door.left.lock by vars.lock.door.left_lock;
    sensor.door.right.locked = delay lock.door.right.lock by vars.lock.door.right_lock;

    // gear
    // high position
    sensor.gear.up.front.unlocked = delay lock.gear.up.front.unlock by vars.lock.gear.up.front_unlock;
    sensor.gear.up.left.unlocked = delay lock.gear.up.left.unlock by vars.lock.gear.up.left_unlock;
    sensor.gear.up.right.unlocked = delay lock.gear.up.right.unlock by vars.lock.gear.up.right_unlock;

    sensor.gear.up.front.locked = delay lock.gear.up.front.lock by vars.lock.gear.up.front_lock;
    sensor.gear.up.left.locked = delay lock.gear.up.left.lock by vars.lock.gear.up.left_lock;
    sensor.gear.up.right.locked = delay lock.gear.up.right.lock by vars.lock.gear.up.right_lock;
    // down position
    sensor.gear.down.front.unlocked = delay lock.gear.down.front.unlock by vars.lock.gear.down.front_unlock;
    sensor.gear.down.left.unlocked = delay lock.gear.down.left.unlock by vars.lock.gear.down.left_unlock;
    sensor.gear.down.right.unlocked = delay lock.gear.down.right.unlock by vars.lock.gear.down.right_unlock;

    sensor.gear.down.front.locked = delay lock.gear.down.front.lock by vars.lock.gear.down.front_lock;
    sensor.gear.down.left.locked = delay lock.gear.down.left.lock by vars.lock.gear.down.left_lock;
    sensor.gear.down.right.locked = delay lock.gear.down.right.lock by vars.lock.gear.down.right_lock;

    // relations between cylinders and sensors
    sensor.gear.front.retracted = delay cylinder.gear.front.retracted by 1ms;
    sensor.gear.left.retracted = delay cylinder.gear.left.retracted by 1ms;
    sensor.gear.right.retracted = delay cylinder.gear.right.retracted by 1ms;

    sensor.gear.front.extended = delay cylinder.gear.front.extended by 1ms;
    sensor.gear.left.extended = delay cylinder.gear.left.extended by 1ms;
    sensor.gear.right.extended = delay cylinder.gear.right.extended by 1ms;

    sensor.door.front.closed = delay cylinder.door.front.retracted by 1ms;
    sensor.door.left.closed = delay cylinder.door.left.retracted by 1ms;
    sensor.door.right.closed = delay cylinder.door.right.retracted by 1ms;

    sensor.door.front.open = delay cylinder.door.front.extended by 1ms;
    sensor.door.left.open = delay cylinder.door.left.extended by 1ms;
    sensor.door.right.open = delay cylinder.door.right.extended by 1ms;

    // reation between shock absorbers and flying/being on ground
    sensor.gear.shockabsorbers.relaxed = delay flying by 1ms;
    sensor.gear.shockabsorbers.compressed = delay onground by 1ms;

    // relation between general valve and pressure sensor
    sensor.pressure.present = delay valve.general.open by 1s;
    sensor.pressure.lacking = delay valve.general.close by 3.6s;

    cycle {
        var start, finish : clock;
        finish = sensor.pressure.lacking;
    };
    handle {
        var action : clock;
        (action $ 1) = delay action by handle.committed.d;

        committed {
            var up,down,action : clock;
            // because it is not possible to cancel action, the action will be considered committed until the cycle completes
            action = first sample handle.action on cycle.finish;
            action = up xor down [handle.committed.rate];
            cycle.start = action;
        };
    };
    try_flying = accept_flying xor reject_flying;
    forbid accept_flying from flying until onground;
    forbid accept_flying from sensor.gear.retracted until sensor.gear.extended;
    forbid accept_flying from cycle.start until cycle.finish;
    try_landing = accept_landing xor reject_landing;
    allow accept_landing from flying until onground;
    allow accept_landing from sensor.gear.extended until sensor.gear.retracted;
    forbid accept_landing from cycle.start until cycle.finish;
    flying = delay accept_flying by 1ms;
    onground = delay accept_landing by 1ms;
    switch {
        var open,close,deadline,try_open : clock;
        close alternates open;
        begin_closing = (first sample handle.committed.action on open);
        close = (delay begin_closing by 0.8s);
        deadline = delay handle.action by 20s;
        non_cancelled_deadline = deadline except cancelled_deadline;
        duplicate_action = handle.action except begin_closing;
        cancelled_deadline = sample duplicate_action on non_cancelled_deadline;
        try_open = delay non_cancelled_deadline by 1.2s;
        open = try_open except (sample (sample non_cancelled_deadline on duplicate_action) on try_open);
    };
    controller {
        module1 {
            command {
                valve {
                    general {
                        var open, close : clock;
                    };
                    gear {
                        retraction {
                            var open, close: clock;
                        };
                        extension {
                            var open, close: clock;
                        };
                    };
                    door {
                        retraction {
                            var open, close: clock;
                        };
                        extension {
                            var open, close: clock;
                        };
                    };
                };
                lock {
                    door {
                        var lock,unlock : clock;
                    };
                    gear {
                        up {
                            var lock,unlock : clock;
                        };
                        down {
                            var lock,unlock : clock;
                        };
                    };
                };
            };
            extension {
                start = handle.committed.down;
                command.valve.general.open += delay start by 1s; // TODO: need a better way to know the switch state
                command.lock.door.unlock += delay (sample start on sensor.pressure.present) by 1ms;
                command.valve.door.extension.open += delay (sample start on sensor.door.unlocked) by 1ms;
                maybe_extension = (sample start on sensor.door.open);
                maybe_extension = avoid_extension xor start_extension;
                start_extension = shock_relaxed and gear_retracted;
                start_extension = shock_relaxed or gear_retracted;
                avoid_extension = shock_compressed or gear_extended;
                allow shock_relaxed from sensor.gear.shockabsorbers.relaxed until sensor.gear.shockabsorbers.compressed;
                allow gear_retracted from sensor.gear.retracted until sensor.gear.extended;
                forbid shock_compressed from sensor.gear.shockabsorbers.relaxed until sensor.gear.shockabsorbers.compressed;
                forbid gear_extended from sensor.gear.retracted until sensor.gear.extended;
                command.lock.gear.up.unlock += delay start_extension by 1ms;
                command.valve.gear.extension.open += delay (sample start_extension on sensor.gear.up.unlocked) by 1ms;
                command.lock.gear.down.lock += delay (sample start_extension on sensor.gear.extended) by 1ms;
                reverse = delay (sample start_extension on sensor.gear.down.locked) by 1ms;
                command.valve.gear.extension.close += reverse; 
                command.valve.door.extension.close += reverse or avoid_extension; 
                command.valve.door.retraction.open += reverse or avoid_extension;
                command.lock.door.lock += delay (sample start on sensor.door.closed) by 1ms;
                door_locked = (sample start on sensor.door.locked);
                command.valve.door.retraction.close += delay door_locked by 1ms;
                command.valve.general.close += delay door_locked by 4ms;
            };
            retraction {
                start = handle.committed.up;
                command.valve.general.open += delay start by 1s;
                command.lock.door.unlock += delay (sample start on sensor.pressure.present) by 1ms;
                command.valve.door.extension.open += delay (sample start on sensor.door.unlocked) by 1ms;
                maybe_retraction = sample start on sensor.door.open;
                maybe_retraction = start_retraction xor avoid_retraction;
                start_retraction = shock_relaxed and gear_extended;
                start_retraction = shock_relaxed or gear_extended;
                avoid_retraction = shock_compressed or gear_retracted;
                forbid shock_relaxed from sensor.gear.shockabsorbers.compressed until sensor.gear.shockabsorbers.relaxed;
                forbid gear_extended from sensor.gear.retracted until sensor.gear.extended;
                allow shock_compressed from sensor.gear.shockabsorbers.compressed until sensor.gear.shockabsorbers.relaxed;
                allow gear_retracted from sensor.gear.retracted until sensor.gear.extended;
                command.lock.gear.down.unlock += delay start_retraction by 1ms;
                command.valve.gear.retraction.open += delay (sample start_retraction on sensor.gear.down.unlocked) by 1ms;
                command.lock.gear.up.lock += delay (sample start_retraction on sensor.gear.retracted) by 1ms;
                reverse = delay (sample start_retraction on (sensor.gear.up.locked)) by 1ms;
                command.valve.gear.retraction.close += reverse;
                command.valve.door.extension.close += reverse or avoid_retraction;
                command.valve.door.retraction.open += reverse or avoid_retraction;
                command.lock.door.lock += delay (sample start on sensor.door.closed) by 1ms;
                door_locked = (sample start on sensor.door.locked);
                command.valve.door.retraction.close += delay door_locked by 1ms;
                command.valve.general.close += delay door_locked by 4ms;
            };
        };
        module2 {
            command {
                valve {
                    general {
                        var open, close : clock;
                    };
                    gear {
                        retraction {
                            var open, close: clock;
                        };
                        extension {
                            var open, close: clock;
                        };
                    };
                    door {
                        retraction {
                            var open, close: clock;
                        };
                        extension {
                            var open, close: clock;
                        };
                    };
                };
                lock {
                    door {
                        var lock,unlock : clock;
                    };
                    gear {
                        up {
                            var lock,unlock : clock;
                        };
                        down {
                            var lock,unlock : clock;
                        };
                    };
                };
            };
            extension {
                start = handle.committed.down;
                command.valve.general.open += delay start by 1s; // TODO: need a better way to know the switch state
                command.lock.door.unlock += delay (sample start on sensor.pressure.present) by 1ms;
                command.valve.door.extension.open += delay (sample start on sensor.door.unlocked) by 1ms;
                maybe_extension = (sample start on sensor.door.open);
                maybe_extension = avoid_extension xor start_extension;
                start_extension = shock_relaxed and gear_retracted;
                start_extension = shock_relaxed or gear_retracted;
                avoid_extension = shock_compressed or gear_extended;
                allow shock_relaxed from sensor.gear.shockabsorbers.relaxed until sensor.gear.shockabsorbers.compressed;
                allow gear_retracted from sensor.gear.retracted until sensor.gear.extended;
                forbid shock_compressed from sensor.gear.shockabsorbers.relaxed until sensor.gear.shockabsorbers.compressed;
                forbid gear_extended from sensor.gear.retracted until sensor.gear.extended;
                command.lock.gear.up.unlock += delay start_extension by 1ms;
                command.valve.gear.extension.open += delay (sample start_extension on sensor.gear.up.unlocked) by 1ms;
                command.lock.gear.down.lock += delay (sample start_extension on sensor.gear.extended) by 1ms;
                reverse = delay (sample start_extension on sensor.gear.down.locked) by 1ms;
                command.valve.gear.extension.close += reverse; 
                command.valve.door.extension.close += reverse or avoid_extension; 
                command.valve.door.retraction.open += reverse or avoid_extension;
                command.lock.door.lock += delay (sample start on sensor.door.closed) by 1ms;
                door_locked = (sample start on sensor.door.locked);
                command.valve.door.retraction.close += delay door_locked by 1ms;
                command.valve.general.close += delay door_locked by 4ms;
            };
            retraction {
                start = handle.committed.up;
                command.valve.general.open += delay start by 1s;
                command.lock.door.unlock += delay (sample start on sensor.pressure.present) by 1ms;
                command.valve.door.extension.open += delay (sample start on sensor.door.unlocked) by 1ms;
                maybe_retraction = sample start on sensor.door.open;
                maybe_retraction = start_retraction xor avoid_retraction;
                start_retraction = shock_relaxed and gear_extended;
                start_retraction = shock_relaxed or gear_extended;
                avoid_retraction = shock_compressed or gear_retracted;
                forbid shock_relaxed from sensor.gear.shockabsorbers.compressed until sensor.gear.shockabsorbers.relaxed;
                forbid gear_extended from sensor.gear.retracted until sensor.gear.extended;
                allow shock_compressed from sensor.gear.shockabsorbers.compressed until sensor.gear.shockabsorbers.relaxed;
                allow gear_retracted from sensor.gear.retracted until sensor.gear.extended;
                command.lock.gear.down.unlock += delay start_retraction by 1ms;
                command.valve.gear.retraction.open += delay (sample start_retraction on sensor.gear.down.unlocked) by 1ms;
                command.lock.gear.up.lock += delay (sample start_retraction on sensor.gear.retracted) by 1ms;
                reverse = delay (sample start_retraction on (sensor.gear.up.locked)) by 1ms;
                command.valve.gear.retraction.close += reverse;
                command.valve.door.extension.close += reverse or avoid_retraction;
                command.valve.door.retraction.open += reverse or avoid_retraction;
                command.lock.door.lock += delay (sample start on sensor.door.closed) by 1ms;
                door_locked = (sample start on sensor.door.locked);
                command.valve.door.retraction.close += delay door_locked by 1ms;
                command.valve.general.close += delay door_locked by 4ms;
            };
        };
        // because the outputs using OR-gate to combine the output of controllers, we use fastest and slowest constraints
        command {
            valve {
                general {
                    var open, close : clock;
                    open = fastest of module1.command.valve.general.open module2.command.valve.general.open;
                    close = slowest of module1.command.valve.general.close module2.command.valve.general.close;
                    allow open close from switch.close until switch.open;
                };
                gear {
                    retraction {
                        var open, close: clock;
                        open = fastest of module1.command.valve.gear.retraction.open module2.command.valve.gear.retraction.open;
                        close = slowest of module1.command.valve.gear.retraction.close module2.command.valve.gear.retraction.close;
                    };
                    extension {
                        var open, close: clock;
                        open = fastest of module1.command.valve.gear.extension.open module2.command.valve.gear.extension.open;
                        close = slowest of module1.command.valve.gear.extension.close module2.command.valve.gear.extension.close;
                    };
                };
                door {
                    retraction {
                        var open, close: clock;
                        open = fastest of module1.command.valve.door.retraction.open module2.command.valve.door.retraction.open;
                        close = slowest of module1.command.valve.door.retraction.close module2.command.valve.door.retraction.close;
                    };
                    extension {
                        var open, close: clock;
                        open = fastest of module1.command.valve.door.extension.open module2.command.valve.door.extension.open;
                        close = slowest of module1.command.valve.door.extension.close module2.command.valve.door.extension.close;
                    };
                };
            };
            lock {
                door {
                    var lock,unlock : clock;
                    lock = fastest of module1.command.lock.door.lock module2.command.lock.door.lock;
                    unlock = fastest of module1.command.lock.door.unlock module2.command.lock.door.unlock;
                };
                gear {
                    up {
                        var lock,unlock : clock;
                        lock = fastest of module1.command.lock.gear.up.lock module2.command.lock.gear.up.lock;
                        unlock = fastest of module1.command.lock.gear.up.unlock module2.command.lock.gear.up.unlock;
                    };
                    down {
                        var lock,unlock : clock;
                        lock = fastest of module1.command.lock.gear.down.lock module2.command.lock.gear.down.lock;
                        unlock = fastest of module1.command.lock.gear.down.unlock module2.command.lock.gear.down.unlock;
                    };
                };
            };
        };
        indicate {
            var locked, maneuvering, anomaly : clock;
        }; 
    };

    // connection between controller commands and actuators
    valve.general.open = delay controller.command.valve.general.open by 1ms;
    valve.general.close = delay controller.command.valve.general.close by 1ms;

    valve.door.retraction.open = delay controller.command.valve.door.retraction.open by 1ms;
    valve.door.retraction.close = delay controller.command.valve.door.retraction.close by 1ms;

    valve.door.extension.open = delay controller.command.valve.door.extension.open by 1ms;
    valve.door.extension.close = delay controller.command.valve.door.extension.close by 1ms;

    valve.gear.retraction.open = delay controller.command.valve.gear.retraction.open by 1ms;
    valve.gear.retraction.close = delay controller.command.valve.gear.retraction.close by 1ms;

    valve.gear.extension.open = delay controller.command.valve.gear.extension.open by 1ms;
    valve.gear.extension.close = delay controller.command.valve.gear.extension.close by 1ms;

    // relations between commands and door locks
    lock.door.front.unlock = delay controller.command.lock.door.unlock by 1ms;
    lock.door.left.unlock = delay controller.command.lock.door.unlock by 1ms;
    lock.door.right.unlock = delay controller.command.lock.door.unlock by 1ms;
    lock.door.front.lock = delay controller.command.lock.door.lock by 1ms;
    lock.door.left.lock = delay controller.command.lock.door.lock by 1ms;
    lock.door.right.lock = delay controller.command.lock.door.lock by 1ms;

    // relations between commands and gear locks
    lock.gear.up.front.unlock = delay controller.command.lock.gear.up.unlock by 1ms;
    lock.gear.up.left.unlock = delay controller.command.lock.gear.up.unlock by 1ms;
    lock.gear.up.right.unlock = delay controller.command.lock.gear.up.unlock by 1ms;
    lock.gear.up.front.lock = delay controller.command.lock.gear.up.lock by 1ms;
    lock.gear.up.left.lock = delay controller.command.lock.gear.up.lock by 1ms;
    lock.gear.up.right.lock = delay controller.command.lock.gear.up.lock by 1ms;

    lock.gear.down.front.unlock = delay controller.command.lock.gear.down.unlock by 1ms;
    lock.gear.down.left.unlock = delay controller.command.lock.gear.down.unlock by 1ms;
    lock.gear.down.right.unlock = delay controller.command.lock.gear.down.unlock by 1ms;
    lock.gear.down.front.lock = delay controller.command.lock.gear.down.lock by 1ms;
    lock.gear.down.left.lock = delay controller.command.lock.gear.down.lock by 1ms;
    lock.gear.down.right.lock = delay controller.command.lock.gear.down.lock by 1ms;
} assert {
    // should not have a conflict between the commands to the controllers
    handle.committed.action = handle.committed.up xor handle.committed.down;

    // should not open opposing valves
    mutex {
        valve.door.retraction.open -> valve.door.retraction.close,
        valve.door.extension.open -> valve.door.extension.close,
    };
    mutex {
        valve.gear.retraction.open -> valve.gear.retraction.close,
        valve.gear.extension.open -> valve.gear.extension.close,
    }
}